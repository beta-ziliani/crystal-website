---
title: "Four tools that will make your work easier"
author: beta-ziliani
summary: "Know these tools that Manas and Bright help shape together"
---

## `crystal tool dependencies`: print the graph of requires

One task given to the Manas team was to split a monolithic app in two, each one having a distinctive feature. For that, it was necessary to know which where the files used by each feature, and which where the common files used by the two.

To solve this task we created `crystal tool dependencies`.

For instance, say we have file `two_features.cr` requiring `feature1.cr` and `feature2.cr`, and each of these in turn requires `common.cr`, and this last one requires stdlib's `big` package. We can run

```bash
crystal tool dependencies two_features.cr
```

to obtain the order in which files are processed:

```bash
feature1.cr
  common.cr
feature2.cr
```

In order to better understand it, let's see the result with the `--verbose` flag:

```bash
../../../../lib/crystal/src/prelude.cr filtered
feature1.cr
  common.cr
    ../../../../lib/crystal/src/big.cr filtered
feature2.cr
  common.cr duplicate skipped
```

What this is saying is that `two_features.cr` requires `feature1.cr` and `feature2.cr`, and each of these in turn require `common.cr`, which then requires `big`. Note the comments `duplicate skipped` and `filtered`: the first one informs us that `common.cr` was processed before (when it was required by `feature1.cr`), so it won't be processed any further, and `filtered` informs us that certain paths are not considered, in this case, those coming from the stdlib. If we want to force the output for certain file, we can add `--include <file>`. Likewise, we can remove a file with `--exclude`.

The tool supports different formats, provided by the flag `-f`: `tree` is the default and produces the output we saw above. `mermaid` and `dot` produces graphs in those two formats.

## `crystal tool unreachable`: finding unused defs

When dealing with a large codebase, it's often the case that we end up defs that are no longer in use, just rotting there until some caritative soul decides to wipe them out. This tool helps finding such defs.

Continuing with the example from the previous section, if `common.cr` is as follow:

```crystal
require "big"

def top_not_used
end

class NotUsed
  def class_not_used
  end
end
```

And the two defs are not called anywhere else, then `crystal tool unreachable two_features.cr` outputs (edited):

```bash
[...]/src/common.cr:3:1 top-level top_not_used 2 lines
[...]/src/common.cr:7:3 NotUsed#class_not_used 2 lines
```

The output is self-explanatory: at the beginning of line 3 starts a top-level def that takes two lines, and in column 3 of line 7 starts another def from class `NotUsed` (also, two lines). We can safely erase these defs and our application should compile and work the same.

Currently it has some limitations: it only processes defs that are not macro-generated. It doesn't consider unused classes, modules, structs, files, etc.

It is possible to change the format of the output with the `-f` flag: `text` is the default format, and `json` is an alternative option. In the example above, `-f json` produces:

```json
[
  {
    "name": "top-level top_not_used",
    "location": "/Users/beta/tmp/crystal/dependencies/src/common.cr:3:1",
    "lines": 2
  },
  {
    "name": "WithNotUsed#class_not_used",
    "location": "/Users/beta/tmp/crystal/dependencies/src/common.cr:7:3",
    "lines": 2
  }
]
```

## The shard `perf_tools`: profiling memory and fibers

The new [crystal-lang](https://github.com/crystal-lang) repository [perf-tools](https://github.com/crystal-lang/perf-tools) contains a development shard with, at the moment of writing, two handy tools: a memory profiler and a fiber profiler. In order to use it in your project, first add the dependency in the `shards.yml` file (detailed instructions in the readme). Then, follow instructions according to the case.

### Finding leaks with `perf_tools/mem_prof`

Say we have an application that first calculates the maximum size of auto-generated strings:

```crystal
def calculate_max
  max = 0
  (1..1000).each do |i|
    s = "crystal" * i
    Logger.log s
    max = s.size if s.size > max
  end
  max
end
```

We note that after calling `calculate_max` the app takes a huge amount of memory. We insert an explicit `GC.collect` but to no avail. We confirm the leak by requiring `perf_tools/mem_prof` and calling it after calculating the max:

```crystal
max = calculate_max
PerfTools::MemProf.pretty_log_allocations(STDOUT)
```

After executing the program, it prints:

| Allocations | Total size | Context |
|------------:|-----------:|---------|
| 999 | 3,509,487 | ` src/memory-consuming.cr:19:5 in 'calculate_max' `<br>` src/memory-consuming.cr:30:1 in '__crystal_main' `<br>` /Users/beta/projects/crystal/crystal/src/crystal/main.cr:129:5 in 'main_user_code' `<br>` /Users/beta/projects/crystal/crystal/src/crystal/main.cr:115:7 in 'main' `<br>` /Users/beta/projects/crystal/crystal/src/crystal/main.cr:141:3 in 'main' ` |
|   2 |     8,304 | ` /Users/beta/projects/crystal/crystal/src/array.cr:2100:17 in 'resize_to_capacity' `<br>` /Users/beta/projects/crystal/crystal/src/array.cr:2094:5 in 'increase_capacity' `<br>` /Users/beta/projects/crystal/crystal/src/array.cr:2026:7 in 'check_needs_resize' `<br>` /Users/beta/projects/crystal/crystal/src/array.cr:1363:5 in 'push' `<br>` /Users/beta/projects/crystal/crystal/src/array.cr:401:5 in '<<' ` |
|   1 |     7,013 | ` src/memory-consuming.cr:19:5 in 'calculate_max' `<br>` src/memory-consuming.cr:30:1 in '__crystal_main' `<br>` /Users/beta/projects/crystal/crystal/src/crystal/main.cr:129:5 in 'main_user_code' `<br>` /Users/beta/projects/crystal/crystal/src/crystal/main.cr:115:7 in 'main' `<br>` /Users/beta/projects/crystal/crystal/src/crystal/main.cr:141:3 in 'main' ` |

We see the leak immediately: those 999 allocations. Inspecting the stack trace we note they come from the auto-generated strings. We still don't know who's holding those strings though. So we call another tool, the object size counter:

```crystal
PerfTools::MemProf.log_object_sizes(STDOUT)
```

We obtain the following (trimmed) table:

```text
26
4 (class 94)
216 (class 137)
80 Crystal::SpinLock
16 (class 93)
24 (class 20)
3524852 Array(String)
24 (class 143)
24 (class 163)
...
```

We know now that `Array(String)` is the class with the biggest sum of object sizes. But how many `Array(String)`s are there? We call

```crystal
PerfTools::MemProf.log_object_counts(STDOUT)
```

And obtain (trimmed):

```text
...
1 Hash(String, NamedTuple(time: Time, location: Time::Location))
1 Array(String)
```

So just one array is holding all the `String` references! Looking at the stack traces from the first table, we see that indeed there is an operation on an array taking some size. But the stack is not enough to inform us where is it coming from, so we expand the number of stack traces to include and print the table again. One option is to re-run the application with the environment variable `MEMPROF_STACK_DEPTH` set to a higher value (default is 5).

Looking at that specific line we note that now it's blaming the `log` method.

|------------:|-----------:|---------|
|   1 |     8,256 | ` /Users/beta/projects/crystal/crystal/src/array.cr:2100:17 in 'resize_to_capacity' `<br>` /Users/beta/projects/crystal/crystal/src/array.cr:2094:5 in 'increase_capacity' `<br>` /Users/beta/projects/crystal/crystal/src/array.cr:2026:7 in 'check_needs_resize' `<br>` /Users/beta/projects/crystal/crystal/src/array.cr:1363:5 in 'push' `<br>` /Users/beta/projects/crystal/crystal/src/array.cr:401:5 in '<<' `<br>` src/memory-consuming.cr:12:5 in 'log' `<br>` src/memory-consuming.cr:7:3 in 'log' ` |

Aha! The person that added the logging didn't know Crystal comes with its own logging framework, and created it's own leaky one!

```crystal
class Logger
  @@values = Array(String).new

  def self.log(what : String, print = false)
    puts what if print
    @@values << what
  end
end
```

The tool can be tweaked with other parameters as well, as how many stack traces to skip, from which size start considering allocations, etc.

### Profiling fibers with `fiber_trace`

We have a useful little tool to track fibers. In a program having several fibers, this tool allow us to show fibers that might be idly waiting for some resource that would never be available.

For instance, let's say we have a program to remove concurrently elements from an array `values` (note: for this example we're assuming no multi-threading). We add some random waiting just to make results unpredictable, and we add one fiber that will get stuck.

```crystal
values.each do |i|
  spawn name: "Worker #{i}" do
    sleep (rand 5000).milliseconds
    if i == 5
      while true
        Fiber.yield
      end
    end
    values.delete i
  end
end

# we wait until all of the values are removed
while values.size > 0
  Fiber.yield
end
```

If we run this program, giving some array of numbers as `values`, it will naturally get stuck at some point. We can then add a little helper fiber to print the fibers that are running, until finding the one that's stuck.

```crystal
spawn name: "Logger" do
  while true
    puts "\x1b[2J" # clear the screen
    PerfTools::FiberTrace.pretty_log_fibers(STDOUT)
    sleep 500.milliseconds
  end
end
```
