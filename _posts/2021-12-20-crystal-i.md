---
title: Crystal's interpreter – What to expect
summary:
thumbnail: +
author: beta-ziliani
---

We are getting close to the feature freeze period for Crystal 1.3. This time, this release is a bit special for the _Crystallers_ [(?)](https://forum.crystal-lang.org/t/what-are-crystal-programmers-called/4115), as the awaited Crystal interpreter has been [merged](https://github.com/crystal-lang/crystal/pull/11159). But beware! That doesn't mean you can use it out of the box: Crystal must be compiled with a special flag and, at the time of writing, the official releases (`.deb`, `.rpm`, docker images, etc.) are not being compiled with it.

This post is a F.A.Q. for this special feature. Let's start from the very beginning:

## Why Crystal needs an interpreter?

While many will find this one obvious, we'd like to point at at two specific features that an interpreter might enable:

 1. _In principle_ an interpreter should be faster to start executing code since the codegen phase is skipped (see below). Therefore, it should  be faster to execute specific specs, or to quickly test the result of some code, without needing to recompile.
 2. An interpreter improves the experience of debugging, by being an ad-hoc tool to the language (unlike the generic `lldb`).

## What is the current status?

The interpreter is yet experimental, with lots of [missing bits](https://github.com/crystal-lang/crystal/issues/11555). The reason to merge it in this early stage is to be able to properly discuss interpreter-related PRs in isolation and speed-up a bit its development. To give an example of a essential feature missing, at the time of writing it can't properly run `spec`s.

## How does it work?

The original [PR](https://github.com/crystal-lang/crystal/pull/11159) answers it:

> When running in interpreted mode, semantic analysis is done as usual, but instead of then using LLVM to generate code, we compile code to bytecode (custom bytecode defined in this PR, totally unrelated to LLVM). Then there's an interpreter that understands this bytecode.

## How do I invoke it?

⚠️ This is not written in stone!

Assuming you've compiled Crystal passing the flag `interpreter=1` to `make`, you can invoke it with `crystal i`. From the PR:

> It can be used in two modes right now:
>
> 1. `crystal i`: opens an interactive crystal session (REPL) similar to `irb` from Ruby.
> 2. `crystal i file.cr`: runs a file in interpreted mode.
>
> In any of these two modes, you can use `debugger` in your code to debug it at that point. This is similar to Ruby's `pry`. There you can use these commands (similar to `pry` too):
>
> * `step`: go to the next line/instruction, possibly going inside a method.
> * `next`: go to the next line/instruction, doesn't enter into methods.
> * `finish`: exit the current method.
> * `continue`: resume execution.
> * `whereami`: show where the debugger is.

## How faster it loads a program?

We're definitively missing benchmarks, but testing on a few random files from the standard library, it loads them in between 50 and 75% the time it takes to compile them (executing `time crystal <file>` vs. `time crystal i <file>`). This time depends significantly on how much time Crystal takes on the common steps to the compiler and the interpreter, like parsing and semantic analysis.

## How fast (or slow) it runs?

As Ary, its creator, [showed](https://www.youtube.com/watch?v=een_W1YEICw) in [Crystal Conf 1.0](crystal-lang.org/conference/), it runs sufficiently fast—for an interpreter that is. Of course, it's not nearly as efficient as Ruby, yet in our preliminary tests it runs fast for the expected use cases. Using the interpreter for processing intensive tasks is definitively discouraged...
